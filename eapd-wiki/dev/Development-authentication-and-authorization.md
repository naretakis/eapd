# Authentication

The application uses [Okta](https://okta.com) to provide authentication.
Users must register for an Okta account and be added to the application
user group. Users must also sign up for Multi Factor Authentication (MFA) with Okta. They have the option of using 
voice call, email, sms text, or a software-based authenticator (such as Google 
Authenticator or Okta Authenticator) to provide one-time passwords or multi factor credentials.

Authentication is a multi-step process. The front-end uses the 
`@okta/okta-auth-js` node module to create an oktaClient object that is used to 
interact with Okta. First, the oktaClient sign-in method sends the user's username 
and password to Okta. Okta returns a response with different potential statuses. Error statuses
include LOCKED_OUT or PASSWORD_EXPIRED. The user is instructed on how to handle these situations.

If the user has not yet set up a multi-factor option, Okta will return a status of MFA_ENROLL. The
user will then be walked through the steps to set up their second factor. If they choose to use
email, Okta will use their EUA email. If they choose CALL or SMS, the user will have the option
of supplying a phone number for Okta to use.


If the user has already set up a second factor, Okta will return a status of MFA_REQUIRED. The 
transaction includes an array of factors that the user has set up. That factor has a 
function named verify that will send the  one-time password to the user when it is called. 
The user is then redirected to the page where they will enter the one-time password that 
they received from Okta.

Once the user enters the one-time password, oktaClient resumes the previous 
transaction, which has a verify function that takes the one-time password. If this one-time password is valid, Okta returns a 
transaction with the status 'SUCCESS' and a session token. The front-end then 
uses the oktaClient to get the access token using the session token and a state 
token generated by the front-end. Okta returns the same state token and the 
access tokens. That Okta token is finally exchanged for a token generated by eAPD. The token generated by eAPD will contain all of the information necessary to determine what
resources a user can access.  This JWT is stored in local storage of the user's browser.

Mermaid Diagram [here](https://mermaid-js.github.io/mermaid-live-editor/view/#eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG4gICAgcGFydGljaXBhbnQgVyBhcyBXZWIgQXBwXG4gICAgcGFydGljaXBhbnQgTyBhcyBPa3RhXG4gICAgcGFydGljaXBhbnQgRSBhcyBFQVBEIHNlcnZlclxuICAgIFctPj5POiBBdXRoZW50aWNhdGVcbiAgICBOb3RlIG92ZXIgVyxPOiBva3RhQ2xpZW50LnNpZ25pbih7dXNlcm5hbWUsIHBhc3N3b3JkfSlcbiAgICBPLS0-Plc6IFJldHVybiBUcmFuc2FjdGlvblxuICAgIE5vdGUgb3ZlciBXLE86IFJlc3BvbnNlIHdpdGggQXV0aGVudGljYXRpb24gc3RhdHVzXG4gICAgYWx0IFtzdGF0dXMgPT0gTE9DS0VEX09VVF1cbiAgICAgICAgTm90ZSBsZWZ0IG9mIFc6IFVzZXIgaXMgcmVkaWVjdGVkIHRvIGFjY291bnQgbG9ja2VkIHBhZ2VcbiAgICBlbHNlIFtzdGF0dXMgPT0gTUZBX0VOUk9MTF1cbiAgICAgICAgVy0-Pk86IFJlcXVlc3QgbGlzdCBvZiBzZWNvbmQgZmFjdG9yIG9wdGlvbnNcbiAgICAgICAgTy0tPj5XOiBMaXN0IG9mIHNlY29uZCBmYWN0b3Igb3B0aW9uc1xuICAgICAgICBOb3RlIGxlZnQgb2YgVzogVXNlciBzZWxlY3RzIHNlY29uZCBmYWN0b3Igb3B0aW9uXG4gICAgICAgIGFsdCBbRmFjdG9yIFR5cGUgPT0gQ2FsbCBvciBTTVNdXG4gICAgICAgICAgICBOb3RlIGxlZnQgb2YgVzogVXNlciBzZWxlY3RzIENhbGwgb3IgU01TXG4gICAgICAgICAgICBXLT4-TzogRW5yb2xsIE1GQSB3aXRoIFBob25lIG51bWJlclxuICAgICAgICAgICAgTm90ZSBvdmVyIFcsTzogZmFjdG9yLmVucm9sbCh7cHJvZmlsZToge3Bob25lTnVtYmVyLCB1cGRhdGVQaG9uZTp0cnVlfX0pXG4gICAgICAgIGVsc2UgW0ZhY3RvciBUeXBlID09IEVtYWlsIG9yIFNvZnR3YXJlIFRva2VuXVxuICAgICAgICAgICAgTm90ZSBsZWZ0IG9mIFc6IFVzZXIgc2VsZWN0cyBvdGplciBmYWN0b3JcbiAgICAgICAgICAgIFctPj5POiBFbnJvbGwgTUZBXG4gICAgICAgICAgICBOb3RlIG92ZXIgVyxPOiBmYWN0b3IuZW5yb2xsKHt9KVxuICAgICAgICBlbmRcbiAgICAgICAgTy0tPj5XOiBSZXR1cm4gb25lLXRpbWUgcGFzc3dvcmQgKE9UUClcbiAgICAgICAgTm90ZSBsZWZ0IG9mIFc6IFVzZXIgZW50ZXJzIE9UUFxuICAgICAgICBXLT4-TzogVmVyaWZ5IE1GQVxuICAgICAgICBPLS0-Plc6IFJlc3BvbnNlIHdpdGggYXV0aGVudGljYXRpb24gc3RhdHVzIFNVQ0NFU1NcbiAgICAgICAgTm90ZSBsZWZ0IG9mIFc6IENvbnRpbnVlIHRvIHN0YXR1cyA9PSBTVUNDRVNTXG4gICAgZWxzZSBbc3RhdHVzID09IE1GQSBSRVFVSVJFRF1cbiAgICAgICAgTm90ZSBsZWZ0IG9mIFc6IFVzZXIgZW50ZXJzIE9UUFxuICAgICAgICBXLT4-TzogVmVyaWZ5IE1GQVxuICAgICAgICBOb3RlIG92ZXIgVyxPOiB0cmFuc2FjdGlvbi52ZXJpZnkoe3Bhc3NDb2RlOiBvdHAsIGF1dG9QdXNoOiB0cnVlIH0pXG4gICAgICAgIE8gLS0-PiBXOiBSZXNwb25zZSB3aXRoIGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBTVUNDRVNTXG4gICAgICAgIFxuICAgIGVsc2UgW3N0YXR1cyA9PSBTVUNDRVNTXVxuICAgICAgICBXLT4-TzogUmVxdWVzdCBBY2Nlc3NUb2tlblxuICAgICAgICBOb3RlIG92ZXIgVyxPOiBva3RhQ2xpZW50LnRva2VuLmdldFdpdGhvdXRQcm9tcHQoeyByZXNwb25zZVR5cGUsIHNjb3Blcywgc2Vzc2lvblRva2VuLCBzdGF0ZSwgcHJvbXB0fSlcbiAgICAgICAgTyAtLT4-IFc6IFJlc3BvbnNlIHdpdGggYWNjZXNzIHRva2Vuc1xuICAgICAgICBXIC0-PiBFOiBSZXF1ZXN0IFRva2VuIEV4Y2hhbmdlXG4gICAgICAgIEUgLS0-PiBPOiBDb25maXJtIFRva2VuXG4gICAgICAgIE5vdGUgb3ZlciBPLCBFOiBUb2tlbiBpcyBhbG1vc3QgY2VydGFpbmx5IHZhbGlkIFxuICAgICAgICBPIC0tPj4gRTogVG9rZW4gdmFsaWRcbiAgICAgICAgRS0-PkU6IEZldGNoIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgICAgRS0tPj4gVzogSXNzdWUgSldUIGFjY2VzcyB0b2tlbiB3aXRoIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgICAgTm90ZSBvdmVyIFcsRTogVXNlciBpcyBub3cgbG9nZ2VkIGluXG5cbiAgICBlbmRcbiAgICAgICAgICAgICIsIm1lcm1haWQiOiJ7XG4gIFwidGhlbWVcIjogXCJkZWZhdWx0XCJcbn0iLCJ1cGRhdGVFZGl0b3IiOnRydWUsImF1dG9TeW5jIjp0cnVlLCJ1cGRhdGVEaWFncmFtIjp0cnVlfQ)
(see the [[API configuration documentation|Development backend#runtime configuration]]
for more info on environment variables).


On subsequent calls to the API, the JWT is presented via the 'Authorization'
header of each request. The token is verified using application middleware that results in the user's full
and trusted permission list appended to the request object.  Verification of the token means checking that the signature is valid which prevents a user from tempering with the JWT payload (unless they have the JWT secret key).  This prevents having to pull this information
from the database on each request.  When users make changes to their desired state they are reissued a token with 
the appropriate permissions for their new state.

The front end follows [this flow chart](https://mermaid-js.github.io/mermaid-live-editor/view/#eyJjb2RlIjoiZ3JhcGggVERcbiAgICBZe0NoZWNrIGZvciBFQVBEIFRva2VufSAtLT4gfHllc3wgR1xuICAgIFkgLS0-IHxub3wgWlxuICAgIFp7Q2hlY2sgZm9yIG9rdGEgbG9naW4gY29va2llfSAtLT4gfHllc3wgRFxuXG4gICAgWiAtLT4gfG5vfCBBXG4gICAgQVtFbnRlciBVc2VybmFtZSBhbmQgcGFzc3dvcmRdIC0tPiBCKFZlcmlmeSB3aXRoIE9rdGEpXG5cbiAgICBCIC0tPiBDe1ZhbGlkIExvZ2lufVxuICAgIEMgLS0-fG5vfCBFW2JhZCBsb2dpbiBtZXNzYWdlXVxuICAgIEMgLS0-fHllc3wgRFtFeGNoYW5nZSB0b2tlbiBmb3IgZUFQRCBUb2tlbiBkYXRhXVxuICAgIEQgLS0-IEZbU3RvcmUgVG9rZW4gaW4gY29va2llc11cbiAgICBGIC0tPiBHW1VwZGF0ZSBSZWR1eCBTdG9yZSB3aXRoIHRva2VuXVxuICAgIFxuICAgIEcgLS0-IFd7SGFzIENob3NlbiBTdGF0ZX1cbiAgICBXIC0tPiB8eWVzfCBLXG4gICAgVyAtLT4gfG5vfCBIe0hhcyBhdmFpbGFibGUgc3RhdGVzfVxuICAgIEggLS0-IHx5ZXN8IEl7bW9yZSB0aGFuIG9uZSBzdGF0ZT99XG4gICAgSCAtLT4gfG5vfCBKW0FmZmlsaWF0aW9uIFJlcXVlc3QgU2NyZWVuXVxuICAgIEogLS0-IHx5ZXN8IElcbiAgICBJIC0tPiB8bm98IEtbTG9hZCBTdGF0ZSBEYXRhXSBcbiAgICBJIC0tPiB8eWVzfCBMW0Nob29zZSBTdGF0ZV1cbiAgICBMIC0tPiBLXG5cbiAgICBcbiAgIiwibWVybWFpZCI6IntcbiAgXCJ0aGVtZVwiOiBcImRlZmF1bHRcIlxufSIsInVwZGF0ZUVkaXRvciI6dHJ1ZSwiYXV0b1N5bmMiOnRydWUsInVwZGF0ZURpYWdyYW0iOnRydWV9) for determining what state a user is in with respect to login


# Authorization

We're using a combination of role-based and activity-based authorization:
the actual logic of authorizing requests is purely activity-based, but to
simplify administration, we're using roles to group activities. A user
has a role, and that role identifies what activities they have permission
to perform.

Our [[list of roles and activities|Auth roles and activities]] is available and
updated as new ones are introduced.

## How it works technically

#### Data model

There are three tables to support this authorization model. `auth_activities`
is the full list of activities known to the system. `auth_roles` is,
likewise, the full list of rules. The roles map directly to groups in Okta. 
Finally, there is `auth_role_activity_mapping` that maps a role to a set of activities.

#### The server

A user is assigned a role for a state. When a request arrives from the user, the
JWT is decrypted and a user object is created.  This user object contains all of the
relevant authorization information such as allowed activities and can be trusted because it 
comes directly from the JWT which is tamper proof

From there, we have an authorization middleware called `can`. Each
endpoint can register that it needs authorization by adding a call to
the `can` endpoint during its setup, along with the activity the user
needs in order to be authorized:

```javascript
express.get('/my/path', can('dance-like-nobody-is-watching'), function(req, res, next) { ...
```

The `can` middleware will first use the `loggedIn` middleware to make
sure the user is logged in, and then it will verify that the user object
has the requested activity.

| case                                | result                                                               |
| ----------------------------------- | -------------------------------------------------------------------- |
| not logged in                       | an HTTP 403 status is sent, and the endpoint handler is never called |
| logged in, does not have permission | an HTTP 401 status is sent, and the endpoint handler is never called |
| logged in, has permission           | the endpoint handler is called                                       |
